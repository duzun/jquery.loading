{"version":3,"file":"loading.min.js","sources":["loading.esm.js"],"sourcesContent":["/**\n * A jQuery plugin to add/remove classes to a collection while a promise is pending or something is loading asynchronously.\n *\n * @license MIT\n * @author Dumitru Uzun (DUzun.Me)\n * @version 1.3.0\n */\nexport default function initLoading($) {\n    const lck = '_loading_class_';\n    const lcd = lck + 'disabled_';\n    const prp = 'disabled';\n    /**\n     * Adds/Removes loading class on the collection.\n     *\n     * Usage:\n     *   1)\n     *       $('selector').loading('loading'); // add class\n     *       ...\n     *       $('selector').loading(false); // remove added loading class\n     *\n     *   2)\n     *       const done = $('selector').loading('loading', true); // add class and get the callback\n     *       ...\n     *       done(); // remove added loading class\n     *\n     *   3)\n     *       $('selector').loading('loading', promise); // add class and remove on promise resolve or reject\n     *\n     *   4)\n     *       const done = $('selector').loading('loading', promise); // add class and remove on promise resolve or reject\n     *       setTimeout(done, 5e3); // timeout if promise takes too long\n     *\n     * @param {String|Array} classes  - classes to be added to collection while loading\n     * @param {Boolean|Promise} retCb - if true, return a done() function to be called when done loading\n     *                                - if a promise, remove classes on resolve or reject\n     *\n     * @return {jQuery|Function} - by default (no retCb) it returns the jQuery collection (this),\n     *                             but if retCb not falsy, done() function returned\n     */\n    const loading = function loading(classes, retCb = undefined) {\n        const that = this;\n        if (classes === false) {\n            that.each(function (i, e) {\n                e = $(e);\n                i = e.data(lck);\n                if (i) {\n                    e.removeClass(i).data(lck, undefined);\n                }\n                i = e.data(lcd);\n                if (i) {\n                    e.attr(i, null).prop(i, false).data(lcd, undefined);\n                }\n            });\n        }\n        else {\n            if (retCb) {\n                that.addClass(classes).attr(prp, prp).prop(prp, true);\n                // On `.disabled = true` the element loses focus\n                const focused = that.filter(isFocused);\n                let done = function (a) {\n                    // Prevent calling it more then once\n                    if (done) {\n                        that.removeClass(classes).attr(prp, null).prop(prp, false);\n                        done = undefined;\n                        // Restore the focus on `.disabled = false`\n                        focused.each(reFocusIf);\n                    }\n                    return arguments.length == 1 ? a : that; // in Promises return the result without altering it\n                };\n                // If retCb is a promise, call done() on resolve and reject\n                if (retCb !== true && $.isFunction(retCb.then)) {\n                    retCb.then(done, done);\n                }\n                return done;\n            }\n            that.each(function (i, e) {\n                e = $(e);\n                i = e.data(lck);\n                e.data(lck, (i ? i + ' ' : '') + classes);\n                if (!e.prop(prp)) {\n                    e.attr(prp, prp).prop(prp, true).data(lcd, prp);\n                }\n            })\n                .addClass(classes);\n        }\n        return that;\n    };\n    $.fn.loading = loading;\n    function isFocused() {\n        const elem = this;\n        return elem.ownerDocument.activeElement === elem;\n    }\n    function reFocusIf() {\n        const elem = this;\n        const { ownerDocument } = elem;\n        const { activeElement } = ownerDocument;\n        if (activeElement && (activeElement === elem || activeElement !== ownerDocument.body))\n            return;\n        return elem.focus();\n    }\n    return loading;\n}\n// Auto-init in browser when jQuery or Zepto is present\nif (typeof window !== 'undefined') {\n    const $ = window.jQuery || window.Zepto;\n    if ($) {\n        initLoading($);\n    }\n}\n"],"names":["initLoading","$","lck","lcd","prp","loading","classes","retCb","undefined","that","this","each","i","e","data","removeClass","attr","prop","addClass","focused","filter","isFocused","done","a","reFocusIf","arguments","length","isFunction","then","ownerDocument","activeElement","elem","body","focus","fn","window","jQuery","Zepto"],"mappings":";;;;;;;OAOe,SAASA,EAAYC,OAC1BC,EAAM,kBACNC,EAAMD,EAAM,YACZE,EAAM,WA6BNC,EAAU,SAAiBC,OAASC,8DAAQC,EACxCC,EAAOC,SACG,IAAZJ,EACAG,EAAKE,MAAK,SAAUC,EAAGC,IAEnBD,GADAC,EAAIZ,EAAEY,IACAC,KAAKZ,KAEPW,EAAEE,YAAYH,GAAGE,KAAKZ,OAAKM,IAE/BI,EAAIC,EAAEC,KAAKX,KAEPU,EAAEG,KAAKJ,EAAG,MAAMK,KAAKL,GAAG,GAAOE,KAAKX,OAAKK,UAIhD,IACGD,EAAO,CACPE,EAAKS,SAASZ,GAASU,KAAKZ,EAAKA,GAAKa,KAAKb,GAAK,OAE1Ce,EAAUV,EAAKW,OAAOC,GACxBC,EAAO,SAAUC,UAEbD,IACAb,EAAKM,YAAYT,GAASU,KAAKZ,EAAK,MAAMa,KAAKb,GAAK,GACpDkB,OAAOd,EAEPW,EAAQR,KAAKa,IAEU,GAApBC,UAAUC,OAAcH,EAAId,UAGzB,IAAVF,GAAkBN,EAAE0B,WAAWpB,EAAMqB,OACrCrB,EAAMqB,KAAKN,EAAMA,GAEdA,EAEXb,EAAKE,MAAK,SAAUC,EAAGC,GAEnBD,GADAC,EAAIZ,EAAEY,IACAC,KAAKZ,GACXW,EAAEC,KAAKZ,GAAMU,EAAIA,EAAI,IAAM,IAAMN,GAC5BO,EAAEI,KAAKb,IACRS,EAAEG,KAAKZ,EAAKA,GAAKa,KAAKb,GAAK,GAAMU,KAAKX,EAAKC,MAG9Cc,SAASZ,UAEXG,YAGFY,WACQX,KACDmB,cAAcC,gBADbpB,cAGRc,QACCO,EAAOrB,KACLmB,EAAkBE,EAAlBF,cACAC,EAAkBD,EAAlBC,kBACJA,GAAkBA,IAAkBC,GAAQD,IAAkBD,EAAcG,YAEzED,EAAKE,eAXhBhC,EAAEiC,GAAG7B,QAAUA,EAaRA,EAGX,GAAsB,oBAAX8B,OAAwB,KACzBlC,EAAIkC,OAAOC,QAAUD,OAAOE,MAC9BpC,GACAD,EAAYC"}